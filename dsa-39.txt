1. Definition

AVL Tree is a self-balancing binary search tree (BST).

For every node, the balance factor (BF) = height(left subtree) - height(right subtree) must be -1, 0, or 1.

2. Height of a node
int height(struct node* n) {
    if (n == NULL) return 0;
    return n->height;
}

3. Balance Factor

Formula: BF = height(left subtree) - height(right subtree)

Meaning:

BF = 0 → perfectly balanced

BF = 1 → left heavy

BF = -1 → right heavy

BF >1 or < -1 → imbalance → rotation needed

4. Rotation Cases

Rotations are used to rebalance the tree.

a) Left-Left (LL)

Occurs when insertion in left subtree of left child.

Solution: Right rotation

     z                  y
    / \               /   \
   y   T4   -->      x     z
  / \                   /  \
 x   T3                T3   T4
/ \
T1 T2


Code:

struct node* rightRotate(struct node* y);

b) Right-Right (RR)

Occurs when insertion in right subtree of right child.

Solution: Left rotation

   z                    y
  / \                 /   \
 T1  y       -->     z     x
    / \             / \   / \
   T2  x           T1 T2 T3 T4


Code:

struct node* leftRotate(struct node* x);

c) Left-Right (LR)

Occurs when insertion in right subtree of left child.

Solution: Left rotation on left child → Right rotation on root

      z               z                 x
     / \             / \              /   \
    y   T4   -->    x   T4   -->     y     z
   / \             / \              / \   / \
 T1   x           y  T3            T1 T2 T3 T4
     / \         / \
   T2  T3      T1  T2

d) Right-Left (RL)

Occurs when insertion in left subtree of right child.

Solution: Right rotation on right child → Left rotation on root

5. Insertion

Insert like BST → update height → check balance → rotate if needed.

Sample:

node->height = 1 + max(height(node->left), height(node->right));
int bf = balancefactor(node);

if(bf > 1 && key < node->left->key) return rightrotate(node);  // LL
if(bf < -1 && key > node->right->key) return leftrotate(node);  // RR
if(bf > 1 && key > node->left->key) { // LR
    node->left = leftrotate(node->left);
    return rightrotate(node);
}
if(bf < -1 && key < node->right->key) { // RL
    node->right = rightrotate(node->right);
    return leftrotate(node);
}

6. Deletion

Delete like BST → update height → check balance → rotate if needed.

Same rotation rules apply.

7. Traversal

Preorder → Root Left Right

Inorder → Left Root Right

Postorder → Left Right Root

void preorder(struct node* root){
    if(root != NULL){
        printf("%d ", root->key);
        preorder(root->left);
        preorder(root->right);
    }
}

8. Time Complexity
Operation	Complexity
Search	O(log n)
Insertion	O(log n)
Deletion	O(log n)
9. Quick Interview Tips

Always calculate balance factor after insertion/deletion.

Remember the 4 rotation cases with simple diagrams.

AVL trees are stricter than normal BST → guarantees O(log n) height.

Preorder traversal is often asked to verify the structure after multiple insertions.

10. Example

Insert sequence: 10, 20, 30, 40, 50, 25
Final AVL tree:

       30
      /  \
    20    40
   / \      \
 10  25     50


Preorder = 30 20 10 25 40 50